
Unit and integration testing in nimble is done with nosetests. The expected
method of testing is by calling the script nimble/runTests.py as main.
During development, one may wish to call nosetests directly on some
subsection of the nimble code, for that reason, and the purpose of
organization, there are some guidelines in place about where and how tests
are placed and named, and a couple of exceptions (discussed below) where
organization is strictly enforced.

When running the canonical testing script runTests, every python source file
in the nimble directory tree is checked for test functions or objects, so it
is not strictly necessary that tests be placed in modules that nosetests
will discover. However,  a quick description of nosetests test discovery is
included for developers looking to test portions of the code only. Nosetests
will recursively search through everything in the working directory, looking
for objects which have names that look like tests according to a hardcoded
regular expression. Some helpful highlights with respect to how the regex
works: if a name has a leading '_' it is ignored. If a name starts with 'test'
then it is test related. And if the naming schema is lower_with_underscores
and the name includes an underscore separated 'test' then it will be test
related. For a test function to be run according to test discovery, it must
have a test related name, and be in  a module with a test related name.
Alternatively, it may have a test related name and be in a object with a test
related name that is in a module with a test related name. Note that if a
test function or object is in a module whose name is not recognized during
test discovery by the regular expression (for example a test in the
hypothetical file nimble/foo/bar.py), then it is still possible to call it by
executing nosetests on that particular file (nosetests nimble/foo/bar.py).

The nimble preferred test organization schema is to group all tests for a
package in a subpackage named tests in such a way that it will be tripped by
test discovery (as a courtesy). Roughly, if there is code in nimble/foo/bar.py,
then we expect code that tests bar.py be in (one or more files named)
nimble/foo/tests/baz.py, where the name baz, and the contents of the file
baz.py are named so that test discovery will find and run the tests. Often,
this results in a file named nimble/foo/tests/barTests.py or something similar.

There are two cases where the organization requirements are more stringent,
making use of nosetests test organization at the object or package level
in order to do something otherwise impossible.

Firstly, nimble.interfaces defines interfaces to packages which may not be
present on the host machine. Therefore tests of those interfaces, which
rely on those packages, must be conditionally disabled if the package
is not present. Therefore, if an interface is defined in
nimble/interfaces/foo.py then any module in nimble/interfaces/foo/tests which
relies on the presence of that interface must have foo as substring of its
name. The common case would be 'testfoo' or 'foo_test', but any substring
relation will suffice.

Secondly, nimble.data defines a class hierarchy of objects which share exactly
the same user facing API. It is inconvenient to have to define new tests
for each class, we want instead to write tests for each forward facing
function, and have it run once for each subclass. This is accomplished
by grouping all tests of forward facing methods into objects, each of
which are subclasses of DataTestObject defined in nimble.data.tests.baseObject.
Any subclass of nimble.data.Base must have a corresponding test object placed
in nimble.data.tests.testObjects and subclass from all of the method grouping
objects (StructureBackend, QueryBackend, etc.). During __init__ a call to
super(...).__init__ must be made with a string value to be used for the
returnType parameter of nimble.createData() defining which kind of object to
be tested. Any further tests, for private helpers can also be placed in
that test object. We disallow all other ways of testing nimble.data.Base
subclasses.
